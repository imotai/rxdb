{"version":3,"file":"utils-hash.js","names":["fastUnsecureHash","inputString","doNotUseTextEncoder","hashValue","i","chr","len","encoded","TextEncoder","encode","j","length","push","charCodeAt","toString","defaultHashFunction","input"],"sources":["../../../../src/plugins/utils/utils-hash.ts"],"sourcesContent":["/**\n * This is a very fast hash method\n * but it is not cryptographically secure.\n * For each run it will append a number between 0 and 2147483647 (=biggest 32 bit int).\n * @link http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n * @return a string as hash-result\n */\nexport function fastUnsecureHash(\n    inputString: string,\n    // used to test the polyfill\n    doNotUseTextEncoder?: boolean\n): string {\n    let hashValue = 0,\n        i, chr, len;\n\n    /**\n     * For better performance we first transform all\n     * chars into their ascii numbers at once.\n     *\n     * This is what makes the murmurhash implementation such fast.\n     * @link https://github.com/perezd/node-murmurhash/blob/master/murmurhash.js#L4\n     */\n    let encoded: Uint8Array | number[];\n\n    /**\n     * All modern browsers support the TextEncoder\n     * @link https://caniuse.com/textencoder\n     * But to make RxDB work in other JavaScript runtimes,\n     * like when using it in flutter or QuickJS, we need to\n     * make it work even when there is no TextEncoder.\n     */\n    if (typeof TextEncoder !== 'undefined' && !doNotUseTextEncoder) {\n        encoded = new TextEncoder().encode(inputString);\n    } else {\n        encoded = [];\n        for (let j = 0; j < inputString.length; j++) {\n            encoded.push(inputString.charCodeAt(j));\n        }\n    }\n\n    for (i = 0, len = inputString.length; i < len; i++) {\n        chr = encoded[i];\n        hashValue = ((hashValue << 5) - hashValue) + chr;\n        hashValue |= 0; // Convert to 32bit integer\n    }\n    if (hashValue < 0) {\n        hashValue = hashValue * -1;\n    }\n\n    /**\n     * To make the output smaller\n     * but still have it to represent the same value,\n     * we use the biggest radix of 36 instead of just\n     * transforming it into a hex string.\n     */\n    return hashValue.toString(36);\n}\n\n/**\n * Default hash method used to create revision hashes\n * that do not have to be cryptographically secure.\n * IMPORTANT: Changing the default hashing method\n * requires a BREAKING change!\n */\nexport function defaultHashFunction(input: string): string {\n    return fastUnsecureHash(input);\n}\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,gBAAgB,CAC5BC,WAAmB;AACnB;AACAC,mBAA6B,EACvB;EACN,IAAIC,SAAS,GAAG,CAAC;IACbC,CAAC;IAAEC,GAAG;IAAEC,GAAG;;EAEf;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,OAA8B;;EAElC;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,OAAOC,WAAW,KAAK,WAAW,IAAI,CAACN,mBAAmB,EAAE;IAC5DK,OAAO,GAAG,IAAIC,WAAW,EAAE,CAACC,MAAM,CAACR,WAAW,CAAC;EACnD,CAAC,MAAM;IACHM,OAAO,GAAG,EAAE;IACZ,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,WAAW,CAACU,MAAM,EAAED,CAAC,EAAE,EAAE;MACzCH,OAAO,CAACK,IAAI,CAACX,WAAW,CAACY,UAAU,CAACH,CAAC,CAAC,CAAC;IAC3C;EACJ;EAEA,KAAKN,CAAC,GAAG,CAAC,EAAEE,GAAG,GAAGL,WAAW,CAACU,MAAM,EAAEP,CAAC,GAAGE,GAAG,EAAEF,CAAC,EAAE,EAAE;IAChDC,GAAG,GAAGE,OAAO,CAACH,CAAC,CAAC;IAChBD,SAAS,GAAI,CAACA,SAAS,IAAI,CAAC,IAAIA,SAAS,GAAIE,GAAG;IAChDF,SAAS,IAAI,CAAC,CAAC,CAAC;EACpB;;EACA,IAAIA,SAAS,GAAG,CAAC,EAAE;IACfA,SAAS,GAAGA,SAAS,GAAG,CAAC,CAAC;EAC9B;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,OAAOA,SAAS,CAACW,QAAQ,CAAC,EAAE,CAAC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,mBAAmB,CAACC,KAAa,EAAU;EACvD,OAAOhB,gBAAgB,CAACgB,KAAK,CAAC;AAClC"}