{"version":3,"file":"downstream.js","names":["startReplicationDownstream","state","replicationHandler","input","timer","openTasks","addNewTask","task","stats","down","taskWithTime","time","push","streamQueue","then","useTasks","length","events","active","next","innerTaskWithTime","ensureNotFalsy","shift","lastTimeMasterChangesRequested","downstreamResyncOnce","downstreamProcessChanges","firstSyncDone","getValue","sub","masterChangeStream$","subscribe","masterChangeStreamEmit","firstValueFrom","canceled","pipe","filter","unsubscribe","checkpointQueue","getLastCheckpointDoc","lastCheckpoint","promises","masterChangesSince","pullBatchSize","downResult","documents","stackCheckpoints","checkpoint","persistFromMaster","Promise","all","tasks","docsOfAllTasks","forEach","Error","concat","persistenceQueue","PROMISE_RESOLVE_VOID","nonPersistedFromMaster","docs","docData","docId","primaryPath","downDocsById","useCheckpoint","docIds","Object","keys","writeRowsToFork","writeRowsToForkById","writeRowsToMeta","useMetaWriteRows","forkInstance","findDocumentsById","getAssumedMasterState","currentForkState","assumedMasterState","map","forkStateFullDoc","forkStateDocData","writeDocToDocState","undefined","masterState","assumedMaster","metaDocument","isResolvedConflict","_rev","isAssumedMasterEqualToForkStatePromise","PROMISE_RESOLVE_FALSE","conflictHandler","realMasterState","newDocumentState","r","isEqual","isAssumedMasterEqualToForkState","_meta","identifier","parseRevision","height","areStatesExactlyEqualPromise","areStatesExactlyEqual","getMetaWriteRow","newForkState","assign","flatClone","_attachments","getDefaultRevision","getDefaultRxDocumentMeta","nextRevisionHeight","forkWriteRow","previous","document","bulkWrite","downstreamBulkWriteFlag","forkWriteResult","success","processed","values","error","status","newRxError","writeError","metaInstance","setCheckpoint","unhandledError"],"sources":["../../../src/replication-protocol/downstream.ts"],"sourcesContent":["import {\n    firstValueFrom,\n    filter\n} from 'rxjs';\nimport { newRxError } from '../rx-error';\nimport { stackCheckpoints } from '../rx-storage-helper';\nimport type {\n    RxStorageInstanceReplicationState,\n    BulkWriteRow,\n    BulkWriteRowById,\n    RxStorageReplicationMeta,\n    RxDocumentData,\n    ById,\n    WithDeleted,\n    DocumentsWithCheckpoint\n} from '../types';\nimport {\n    ensureNotFalsy,\n    flatClone,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    parseRevision,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_VOID\n} from '../plugins/utils';\nimport {\n    getLastCheckpointDoc,\n    setCheckpoint\n} from './checkpoint';\nimport { writeDocToDocState } from './helper';\nimport {\n    getAssumedMasterState,\n    getMetaWriteRow\n} from './meta-instance';\n\n/**\n * Writes all documents from the master to the fork.\n * The downstream has two operation modes\n * - Sync by iterating over the checkpoints via downstreamResyncOnce()\n * - Sync by listening to the changestream via downstreamProcessChanges()\n * We need this to be able to do initial syncs\n * and still can have fast event based sync when the client is not offline.\n */\nexport function startReplicationDownstream<RxDocType, CheckpointType = any>(\n    state: RxStorageInstanceReplicationState<RxDocType>\n) {\n    const replicationHandler = state.input.replicationHandler;\n\n    // used to detect which tasks etc can in it at which order.\n    let timer = 0;\n\n\n    type Task = DocumentsWithCheckpoint<RxDocType, any> | 'RESYNC';\n    type TaskWithTime = {\n        time: number;\n        task: Task;\n    };\n    const openTasks: TaskWithTime[] = [];\n\n\n    function addNewTask(task: Task): void {\n        state.stats.down.addNewTask = state.stats.down.addNewTask + 1;\n        const taskWithTime = {\n            time: timer++,\n            task\n        };\n        openTasks.push(taskWithTime);\n        state.streamQueue.down = state.streamQueue.down\n            .then(() => {\n                const useTasks: Task[] = [];\n                while (openTasks.length > 0) {\n                    state.events.active.down.next(true);\n                    const innerTaskWithTime = ensureNotFalsy(openTasks.shift());\n\n                    /**\n                     * If the task came in before the last time we started the pull\n                     * from the master, then we can drop the task.\n                     */\n                    if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {\n                        continue;\n                    }\n\n                    if (innerTaskWithTime.task === 'RESYNC') {\n                        if (useTasks.length === 0) {\n                            useTasks.push(innerTaskWithTime.task);\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    useTasks.push(innerTaskWithTime.task);\n                }\n\n                if (useTasks.length === 0) return;\n\n                if (useTasks[0] === 'RESYNC') {\n                    return downstreamResyncOnce();\n                } else {\n                    return downstreamProcessChanges(useTasks);\n                }\n            }).then(() => {\n                state.events.active.down.next(false);\n                if (!state.firstSyncDone.down.getValue()) {\n                    state.firstSyncDone.down.next(true);\n                }\n            });\n    }\n    addNewTask('RESYNC');\n\n    /**\n     * If a write on the master happens, we have to trigger the downstream.\n     */\n    const sub = replicationHandler\n        .masterChangeStream$\n        .subscribe((task: Task) => {\n            state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;\n            addNewTask(task);\n        });\n    firstValueFrom(\n        state.events.canceled.pipe(\n            filter(canceled => !!canceled)\n        )\n    ).then(() => sub.unsubscribe());\n\n\n    /**\n     * For faster performance, we directly start each write\n     * and then await all writes at the end.\n     */\n    let lastTimeMasterChangesRequested: number = -1;\n    async function downstreamResyncOnce() {\n        state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;\n        if (state.events.canceled.getValue()) {\n            return;\n        }\n\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'down'));\n        let lastCheckpoint: CheckpointType = await state.checkpointQueue;\n\n\n        const promises: Promise<any>[] = [];\n        while (!state.events.canceled.getValue()) {\n            lastTimeMasterChangesRequested = timer++;\n            const downResult = await replicationHandler.masterChangesSince(\n                lastCheckpoint,\n                state.input.pullBatchSize\n            );\n\n            if (downResult.documents.length === 0) {\n                break;\n            }\n\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, downResult.checkpoint]);\n\n            promises.push(\n                persistFromMaster(\n                    downResult.documents,\n                    lastCheckpoint\n                )\n            );\n\n            /**\n             * By definition we stop pull when the pulled documents\n             * do not fill up the pullBatchSize because we\n             * can assume that the remote has no more documents.\n             */\n            if (downResult.documents.length < state.input.pullBatchSize) {\n                break;\n            }\n\n        }\n        await Promise.all(promises);\n    }\n\n\n    function downstreamProcessChanges(tasks: Task[]) {\n        state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;\n        let docsOfAllTasks: WithDeleted<RxDocType>[] = [];\n        let lastCheckpoint: CheckpointType | undefined = null as any;\n\n        tasks.forEach(task => {\n            if (task === 'RESYNC') {\n                throw new Error('SNH');\n            }\n            docsOfAllTasks = docsOfAllTasks.concat(task.documents);\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, task.checkpoint]);\n        });\n        return persistFromMaster(\n            docsOfAllTasks,\n            ensureNotFalsy(lastCheckpoint)\n        );\n    }\n\n\n    /**\n     * It can happen that the calls to masterChangesSince() or the changeStream()\n     * are way faster then how fast the documents can be persisted.\n     * Therefore we merge all incoming downResults into the nonPersistedFromMaster object\n     * and process them together if possible.\n     * This often bundles up single writes and improves performance\n     * by processing the documents in bulks.\n     */\n    let persistenceQueue = PROMISE_RESOLVE_VOID;\n    const nonPersistedFromMaster: {\n        checkpoint?: CheckpointType;\n        docs: ById<WithDeleted<RxDocType>>;\n    } = {\n        docs: {}\n    };\n\n    function persistFromMaster(\n        docs: WithDeleted<RxDocType>[],\n        checkpoint: CheckpointType\n    ): Promise<void> {\n        state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;\n\n        /**\n         * Add the new docs to the non-persistend list\n         */\n        docs.forEach(docData => {\n            const docId: string = (docData as any)[state.primaryPath];\n            nonPersistedFromMaster.docs[docId] = docData;\n        });\n        nonPersistedFromMaster.checkpoint = checkpoint;\n\n        /**\n         * Run in the queue\n         * with all open documents from nonPersistedFromMaster.\n         */\n        persistenceQueue = persistenceQueue.then(() => {\n            const downDocsById: ById<WithDeleted<RxDocType>> = nonPersistedFromMaster.docs;\n            nonPersistedFromMaster.docs = {};\n            const useCheckpoint = nonPersistedFromMaster.checkpoint;\n            const docIds = Object.keys(downDocsById);\n\n            if (\n                state.events.canceled.getValue() ||\n                docIds.length === 0\n            ) {\n                return PROMISE_RESOLVE_VOID;\n            }\n\n            const writeRowsToFork: BulkWriteRow<RxDocType>[] = [];\n            const writeRowsToForkById: ById<BulkWriteRow<RxDocType>> = {};\n            const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta> = {};\n            const useMetaWriteRows: BulkWriteRow<RxStorageReplicationMeta>[] = [];\n\n            return Promise.all([\n                state.input.forkInstance.findDocumentsById(docIds, true),\n                getAssumedMasterState(\n                    state,\n                    docIds\n                )\n            ]).then(([\n                currentForkState,\n                assumedMasterState\n            ]) => {\n                return Promise.all(\n                    docIds.map(async (docId) => {\n                        const forkStateFullDoc: RxDocumentData<RxDocType> | undefined = currentForkState[docId];\n                        const forkStateDocData: WithDeleted<RxDocType> | undefined = forkStateFullDoc ? writeDocToDocState(forkStateFullDoc) : undefined;\n                        const masterState = downDocsById[docId];\n                        const assumedMaster = assumedMasterState[docId];\n\n                        if (\n                            assumedMaster &&\n                            assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev\n                        ) {\n                            /**\n                             * The current fork state represents a resolved conflict\n                             * that first must be send to the master in the upstream.\n                             * All conflicts are resolved by the upstream.\n                             */\n                            return PROMISE_RESOLVE_VOID;\n                        }\n\n                        const isAssumedMasterEqualToForkStatePromise = !assumedMaster || !forkStateDocData ?\n                            PROMISE_RESOLVE_FALSE :\n                            state.input.conflictHandler({\n                                realMasterState: assumedMaster.docData,\n                                newDocumentState: forkStateDocData\n                            }, 'downstream-check-if-equal-0').then(r => r.isEqual);\n                        let isAssumedMasterEqualToForkState = await isAssumedMasterEqualToForkStatePromise;\n\n                        if (\n                            !isAssumedMasterEqualToForkState &&\n                            (\n                                assumedMaster &&\n                                (assumedMaster.docData as any)._rev &&\n                                forkStateFullDoc._meta[state.input.identifier] &&\n                                parseRevision(forkStateFullDoc._rev).height === forkStateFullDoc._meta[state.input.identifier]\n                            )\n                        ) {\n                            isAssumedMasterEqualToForkState = true;\n                        }\n                        if (\n                            (\n                                forkStateFullDoc &&\n                                assumedMaster &&\n                                isAssumedMasterEqualToForkState === false\n                            ) ||\n                            (\n                                forkStateFullDoc && !assumedMaster\n                            )\n                        ) {\n                            /**\n                             * We have a non-upstream-replicated\n                             * local write to the fork.\n                             * This means we ignore the downstream of this document\n                             * because anyway the upstream will first resolve the conflict.\n                             */\n                            return PROMISE_RESOLVE_VOID;\n                        }\n\n\n                        const areStatesExactlyEqualPromise = !forkStateDocData ?\n                            PROMISE_RESOLVE_FALSE :\n                            state.input.conflictHandler({\n                                realMasterState: masterState,\n                                newDocumentState: forkStateDocData\n                            }, 'downstream-check-if-equal-1').then(r => r.isEqual);\n                        const areStatesExactlyEqual = await areStatesExactlyEqualPromise;\n\n                        if (\n                            forkStateDocData &&\n                            areStatesExactlyEqual\n                        ) {\n                            /**\n                             * Document states are exactly equal.\n                             * This can happen when the replication is shut down\n                             * unexpected like when the user goes offline.\n                             *\n                             * Only when the assumedMaster is different from the forkState,\n                             * we have to patch the document in the meta instance.\n                             */\n                            if (\n                                !assumedMaster ||\n                                isAssumedMasterEqualToForkState === false\n                            ) {\n                                useMetaWriteRows.push(\n                                    getMetaWriteRow(\n                                        state,\n                                        forkStateDocData,\n                                        assumedMaster ? assumedMaster.metaDocument : undefined\n                                    )\n                                );\n                            }\n                            return PROMISE_RESOLVE_VOID;\n                        }\n\n                        /**\n                         * All other master states need to be written to the forkInstance\n                         * and metaInstance.\n                         */\n                        const newForkState = Object.assign(\n                            {},\n                            masterState,\n                            forkStateFullDoc ? {\n                                _meta: flatClone(forkStateFullDoc._meta),\n                                _attachments: {},\n                                _rev: getDefaultRevision()\n                            } : {\n                                _meta: getDefaultRxDocumentMeta(),\n                                _rev: getDefaultRevision(),\n                                _attachments: {}\n                            });\n\n                        /**\n                         * If the remote works with revisions,\n                         * we store the height of the next fork-state revision\n                         * inside of the documents meta data.\n                         * By doing so we can filter it out in the upstream\n                         * and detect the document as being equal to master or not.\n                         * This is used for example in the CouchDB replication plugin.\n                         */\n                        if ((masterState as any)._rev) {\n                            const nextRevisionHeight = !forkStateFullDoc ? 1 : parseRevision(forkStateFullDoc._rev).height + 1;\n                            newForkState._meta[state.input.identifier] = nextRevisionHeight;\n                        }\n\n                        const forkWriteRow = {\n                            previous: forkStateFullDoc,\n                            document: newForkState\n                        };\n\n                        writeRowsToFork.push(forkWriteRow);\n                        writeRowsToForkById[docId] = forkWriteRow;\n                        writeRowsToMeta[docId] = getMetaWriteRow(\n                            state,\n                            masterState,\n                            assumedMaster ? assumedMaster.metaDocument : undefined\n                        );\n                    })\n                );\n            }).then(() => {\n                if (writeRowsToFork.length > 0) {\n                    return state.input.forkInstance.bulkWrite(\n                        writeRowsToFork,\n                        state.downstreamBulkWriteFlag\n                    ).then((forkWriteResult) => {\n                        Object.keys(forkWriteResult.success).forEach((docId) => {\n                            state.events.processed.down.next(writeRowsToForkById[docId]);\n                            useMetaWriteRows.push(writeRowsToMeta[docId]);\n                        });\n                        Object.values(forkWriteResult.error).forEach(error => {\n                            /**\n                             * We do not have to care about downstream conflict errors here\n                             * because on conflict, it will be solved locally and result in another write.\n                             */\n                            if (error.status === 409) {\n                                return;\n                            }\n                            // other non-conflict errors must be handled\n                            state.events.error.next(newRxError('RC_PULL', {\n                                writeError: error\n                            }));\n                        });\n                    });\n                }\n            }).then(() => {\n                if (useMetaWriteRows.length > 0) {\n                    return state.input.metaInstance.bulkWrite(\n                        useMetaWriteRows,\n                        'replication-down-write-meta'\n                    );\n                }\n            }).then(() => {\n                /**\n                 * For better performance we do not await checkpoint writes,\n                 * but to ensure order on parallel checkpoint writes,\n                 * we have to use a queue.\n                 */\n                state.checkpointQueue = state.checkpointQueue.then(() => setCheckpoint(\n                    state,\n                    'down',\n                    useCheckpoint\n                ));\n            });\n        }).catch(unhandledError => state.events.error.next(unhandledError));\n        return persistenceQueue;\n    }\n}\n"],"mappings":"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"}