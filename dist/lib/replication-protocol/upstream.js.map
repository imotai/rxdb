{"version":3,"file":"upstream.js","names":["startReplicationUpstream","state","replicationHandler","input","streamQueue","up","then","upstreamInitialSync","processTasks","timer","initialSyncStartTime","openTasks","sub","forkInstance","changeStream","pipe","filter","eventBulk","context","downstreamBulkWriteFlag","subscribe","stats","forkChangeStreamEmit","push","task","time","waitBeforePersist","firstValueFrom","events","canceled","unsubscribe","getValue","checkpointQueue","getLastCheckpointDoc","lastCheckpoint","promises","getChangedDocumentsSince","pushBatchSize","upResult","documents","length","stackCheckpoints","checkpoint","persistToMaster","ensureNotFalsy","Promise","all","resolvedPromises","hadConflicts","find","r","firstSyncDone","next","active","docs","taskWithTime","shift","concat","map","documentData","promise","PROMISE_RESOLVE_FALSE","persistenceQueue","nonPersistedFromMaster","forEach","docData","docId","primaryPath","upDocsById","useCheckpoint","docIds","Object","keys","getAssumedMasterState","assumedMasterState","writeRowsToMaster","writeRowsToMasterIds","writeRowsToMeta","forkStateById","fullDocData","writeDocToDocState","assumedMasterDoc","metaDocument","isResolvedConflict","_rev","conflictHandler","realMasterState","newDocumentState","isEqual","parseRevision","height","_meta","identifier","undefined","getMetaWriteRow","writeRowsArray","values","conflictIds","Set","conflictsById","writeBatches","batchArray","writeBatch","masterWrite","masterWriteResult","conflictDoc","id","add","useWriteRowsToMeta","has","processed","metaInstance","bulkWrite","hadConflictWrites","size","persistToMasterHadConflicts","conflictWriteFork","conflictWriteMeta","entries","writeToMasterRow","resolveConflictError","resolved","resolvedConflicts","output","previous","document","resolvedDoc","persistToMasterConflictWrites","forkWriteResult","useMetaWrites","success","setCheckpoint","unhandledError","error"],"sources":["../../../src/replication-protocol/upstream.ts"],"sourcesContent":["import { firstValueFrom, filter } from 'rxjs';\nimport { stackCheckpoints } from '../rx-storage-helper';\nimport type {\n    BulkWriteRow,\n    BulkWriteRowById,\n    ById,\n    EventBulk,\n    RxDocumentData,\n    RxReplicationWriteToMasterRow,\n    RxStorageChangeEvent,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationMeta,\n    WithDeleted\n} from '../types';\nimport {\n    batchArray,\n    ensureNotFalsy,\n    parseRevision,\n    PROMISE_RESOLVE_FALSE\n} from '../plugins/utils';\nimport {\n    getLastCheckpointDoc,\n    setCheckpoint\n} from './checkpoint';\nimport { resolveConflictError } from './conflicts';\nimport { writeDocToDocState } from './helper';\nimport {\n    getAssumedMasterState,\n    getMetaWriteRow\n} from './meta-instance';\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For initial replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport function startReplicationUpstream<RxDocType, CheckpointType>(\n    state: RxStorageInstanceReplicationState<RxDocType>\n) {\n    const replicationHandler = state.input.replicationHandler;\n    state.streamQueue.up = state.streamQueue.up.then(() => {\n        return upstreamInitialSync().then(() => {\n            processTasks();\n        });\n    });\n\n    // used to detect which tasks etc can in it at which order.\n    let timer = 0;\n    let initialSyncStartTime = -1;\n\n    type Task = EventBulk<RxStorageChangeEvent<RxDocType>, any>;\n    type TaskWithTime = {\n        task: Task;\n        time: number;\n    };\n    const openTasks: TaskWithTime[] = [];\n\n\n    const sub = state.input.forkInstance.changeStream()\n        .pipe(\n            filter(eventBulk => eventBulk.context !== state.downstreamBulkWriteFlag)\n        ).subscribe(eventBulk => {\n            state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n            openTasks.push({\n                task: eventBulk,\n                time: timer++\n            });\n            if (state.input.waitBeforePersist) {\n                return state.input.waitBeforePersist()\n                    .then(() => processTasks());\n            } else {\n                return processTasks();\n            }\n        });\n    firstValueFrom(\n        state.events.canceled.pipe(\n            filter(canceled => !!canceled)\n        )\n    ).then(() => sub.unsubscribe());\n\n\n    async function upstreamInitialSync() {\n        state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n        if (state.events.canceled.getValue()) {\n            return;\n        }\n\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n        let lastCheckpoint: CheckpointType = await state.checkpointQueue;\n\n        const promises: Promise<any>[] = [];\n        while (!state.events.canceled.getValue()) {\n            initialSyncStartTime = timer++;\n            const upResult = await state.input.forkInstance.getChangedDocumentsSince(\n                state.input.pushBatchSize,\n                lastCheckpoint\n            );\n            if (upResult.documents.length === 0) {\n                break;\n            }\n\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n\n            promises.push(\n                persistToMaster(\n                    upResult.documents,\n                    ensureNotFalsy(lastCheckpoint)\n                )\n            );\n        }\n\n        /**\n         * If we had conflicts during the initial sync,\n         * it means that we likely have new writes to the fork\n         * and so we have to run the initial sync again to upstream these new writes.\n         */\n        const resolvedPromises = await Promise.all(promises);\n        const hadConflicts = resolvedPromises.find(r => !!r);\n        if (hadConflicts) {\n            await upstreamInitialSync();\n        } else if (!state.firstSyncDone.up.getValue()) {\n            state.firstSyncDone.up.next(true);\n        }\n    }\n\n\n    /**\n     * Takes all open tasks an processes them at once.\n     */\n    function processTasks() {\n        if (\n            state.events.canceled.getValue() ||\n            openTasks.length === 0\n        ) {\n            state.events.active.up.next(false);\n            return;\n        }\n        state.stats.up.processTasks = state.stats.up.processTasks + 1;\n        state.events.active.up.next(true);\n        state.streamQueue.up = state.streamQueue.up.then(() => {\n            /**\n             * Merge/filter all open tasks\n             */\n            let docs: RxDocumentData<RxDocType>[] = [];\n            let checkpoint: CheckpointType = {} as any;\n            while (openTasks.length > 0) {\n                const taskWithTime = ensureNotFalsy(openTasks.shift());\n                /**\n                 * If the task came in before the last time the initial sync fetching\n                 * has run, we can ignore the task because the initial sync already processed\n                 * these documents.\n                 */\n                if (taskWithTime.time < initialSyncStartTime) {\n                    continue;\n                }\n\n                docs = docs.concat(\n                    taskWithTime.task.events.map(r => {\n                        return r.documentData as any;\n                    })\n                );\n                checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n            }\n\n            const promise = docs.length === 0 ? PROMISE_RESOLVE_FALSE : persistToMaster(\n                docs,\n                checkpoint\n            );\n            return promise.then(() => {\n                if (openTasks.length === 0) {\n                    state.events.active.up.next(false);\n                } else {\n                    processTasks();\n                }\n            });\n        });\n    }\n\n    let persistenceQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n    const nonPersistedFromMaster: {\n        checkpoint?: CheckpointType;\n        docs: ById<RxDocumentData<RxDocType>>;\n    } = {\n        docs: {}\n    };\n\n    /**\n     * Returns true if had conflicts,\n     * false if not.\n     */\n    function persistToMaster(\n        docs: RxDocumentData<RxDocType>[],\n        checkpoint: CheckpointType\n    ): Promise<boolean> {\n        state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n        /**\n         * Add the new docs to the non-persistend list\n         */\n        docs.forEach(docData => {\n            const docId: string = (docData as any)[state.primaryPath];\n            nonPersistedFromMaster.docs[docId] = docData;\n        });\n        nonPersistedFromMaster.checkpoint = checkpoint;\n\n\n        persistenceQueue = persistenceQueue.then(async () => {\n            if (state.events.canceled.getValue()) {\n                return false;\n            }\n\n            const upDocsById: ById<RxDocumentData<RxDocType>> = nonPersistedFromMaster.docs;\n            nonPersistedFromMaster.docs = {};\n            const useCheckpoint = nonPersistedFromMaster.checkpoint;\n            const docIds = Object.keys(upDocsById);\n            if (docIds.length === 0) {\n                return false;\n            }\n\n            const assumedMasterState = await getAssumedMasterState(\n                state,\n                docIds\n            );\n\n            const writeRowsToMaster: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n            const writeRowsToMasterIds: string[] = [];\n            const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta> = {};\n            const forkStateById: ById<RxDocumentData<RxDocType>> = {};\n\n            await Promise.all(\n                docIds.map(async (docId) => {\n                    const fullDocData: RxDocumentData<RxDocType> = upDocsById[docId];\n                    forkStateById[docId] = fullDocData;\n                    const docData: WithDeleted<RxDocType> = writeDocToDocState(fullDocData);\n                    const assumedMasterDoc = assumedMasterState[docId];\n\n                    /**\n                     * If the master state is equal to the\n                     * fork state, we can assume that the document state is already\n                     * replicated.\n                     */\n                    if (\n                        (\n                            assumedMasterDoc &&\n                            // if the isResolvedConflict is correct, we do not have to compare the documents.\n                            assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev\n                            &&\n                            (await state.input.conflictHandler({\n                                realMasterState: assumedMasterDoc.docData,\n                                newDocumentState: docData\n                            }, 'upstream-check-if-equal')).isEqual\n                        )\n                        ||\n                        /**\n                         * If the master works with _rev fields,\n                         * we use that to check if our current doc state\n                         * is different from the assumedMasterDoc.\n                         */\n                        (\n                            assumedMasterDoc &&\n                            (assumedMasterDoc.docData as any)._rev &&\n                            parseRevision(fullDocData._rev).height === fullDocData._meta[state.input.identifier]\n                        )\n                    ) {\n                        return;\n                    }\n\n                    writeRowsToMasterIds.push(docId);\n\n                    writeRowsToMaster[docId] = {\n                        assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n                        newDocumentState: docData\n                    };\n                    writeRowsToMeta[docId] = getMetaWriteRow(\n                        state,\n                        docData,\n                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined\n                    );\n                })\n            );\n\n            if (writeRowsToMasterIds.length === 0) {\n                return false;\n            }\n\n\n            const writeRowsArray = Object.values(writeRowsToMaster);\n            const conflictIds: Set<string> = new Set();\n            const conflictsById: ById<WithDeleted<RxDocType>> = {};\n\n            /**\n             * To always respect the push.batchSize,\n             * we have to split the write rows into batches\n             * to ensure that replicationHandler.masterWrite() is never\n             * called with more documents than what the batchSize limits.\n             */\n            const writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\n            await Promise.all(\n                writeBatches.map(async (writeBatch) => {\n                    const masterWriteResult = await replicationHandler.masterWrite(writeBatch);\n                    masterWriteResult.forEach(conflictDoc => {\n                        const id = (conflictDoc as any)[state.primaryPath];\n                        conflictIds.add(id);\n                        conflictsById[id] = conflictDoc;\n                    });\n                })\n            );\n\n\n            const useWriteRowsToMeta: BulkWriteRow<RxStorageReplicationMeta>[] = [];\n\n\n            writeRowsToMasterIds.forEach(docId => {\n                if (!conflictIds.has(docId)) {\n                    state.events.processed.up.next(writeRowsToMaster[docId]);\n                    useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n                }\n            });\n\n            if (useWriteRowsToMeta.length > 0) {\n                await state.input.metaInstance.bulkWrite(\n                    useWriteRowsToMeta,\n                    'replication-up-write-meta'\n                );\n                // TODO what happens when we have conflicts here?\n            }\n\n            /**\n             * Resolve conflicts by writing a new document\n             * state to the fork instance and the 'real' master state\n             * to the meta instance.\n             * Non-409 errors will be detected by resolveConflictError()\n             */\n            let hadConflictWrites = false;\n            if (conflictIds.size > 0) {\n                state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n                const conflictWriteFork: BulkWriteRow<RxDocType>[] = [];\n                const conflictWriteMeta: BulkWriteRowById<RxStorageReplicationMeta> = {};\n                await Promise.all(\n                    Object\n                        .entries(conflictsById)\n                        .map(([docId, realMasterState]) => {\n                            const writeToMasterRow = writeRowsToMaster[docId];\n                            const input = {\n                                newDocumentState: writeToMasterRow.newDocumentState,\n                                assumedMasterState: writeToMasterRow.assumedMasterState,\n                                realMasterState\n                            };\n                            return resolveConflictError(\n                                state,\n                                input,\n                                forkStateById[docId]\n                            ).then(resolved => {\n                                if (resolved) {\n                                    state.events.resolvedConflicts.next({\n                                        input,\n                                        output: resolved.output\n                                    });\n                                    conflictWriteFork.push({\n                                        previous: forkStateById[docId],\n                                        document: resolved.resolvedDoc\n                                    });\n                                    const assumedMasterDoc = assumedMasterState[docId];\n                                    conflictWriteMeta[docId] = getMetaWriteRow(\n                                        state,\n                                        ensureNotFalsy(realMasterState),\n                                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined,\n                                        resolved.resolvedDoc._rev\n                                    );\n                                }\n                            });\n                        })\n                );\n\n                if (conflictWriteFork.length > 0) {\n                    hadConflictWrites = true;\n\n                    state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n                    const forkWriteResult = await state.input.forkInstance.bulkWrite(\n                        conflictWriteFork,\n                        'replication-up-write-conflict'\n                    );\n                    /**\n                     * Errors in the forkWriteResult must not be handled\n                     * because they have been caused by a write to the forkInstance\n                     * in between which will anyway trigger a new upstream cycle\n                     * that will then resolved the conflict again.\n                     */\n                    const useMetaWrites: BulkWriteRow<RxStorageReplicationMeta>[] = [];\n                    Object\n                        .keys(forkWriteResult.success)\n                        .forEach((docId) => {\n                            useMetaWrites.push(\n                                conflictWriteMeta[docId]\n                            );\n                        });\n                    if (useMetaWrites.length > 0) {\n                        await state.input.metaInstance.bulkWrite(\n                            useMetaWrites,\n                            'replication-up-write-conflict-meta'\n                        );\n                    }\n                    // TODO what to do with conflicts while writing to the metaInstance?\n                }\n            }\n\n            /**\n             * For better performance we do not await checkpoint writes,\n             * but to ensure order on parallel checkpoint writes,\n             * we have to use a queue.\n             */\n            state.checkpointQueue = state.checkpointQueue.then(() => setCheckpoint(\n                state,\n                'up',\n                useCheckpoint\n            ));\n\n            return hadConflictWrites;\n        }).catch(unhandledError => {\n            state.events.error.next(unhandledError);\n            return false;\n        });\n\n        return persistenceQueue;\n    }\n}\n\n"],"mappings":";;;;;;;;;AAAA;AACA;AAaA;AAMA;AAIA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,wBAAwB,CACpCC,KAAmD,EACrD;EACE,IAAMC,kBAAkB,GAAGD,KAAK,CAACE,KAAK,CAACD,kBAAkB;EACzDD,KAAK,CAACG,WAAW,CAACC,EAAE,GAAGJ,KAAK,CAACG,WAAW,CAACC,EAAE,CAACC,IAAI,CAAC,YAAM;IACnD,OAAOC,mBAAmB,EAAE,CAACD,IAAI,CAAC,YAAM;MACpCE,YAAY,EAAE;IAClB,CAAC,CAAC;EACN,CAAC,CAAC;;EAEF;EACA,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,oBAAoB,GAAG,CAAC,CAAC;EAO7B,IAAMC,SAAyB,GAAG,EAAE;EAGpC,IAAMC,GAAG,GAAGX,KAAK,CAACE,KAAK,CAACU,YAAY,CAACC,YAAY,EAAE,CAC9CC,IAAI,CACD,IAAAC,YAAM,EAAC,UAAAC,SAAS;IAAA,OAAIA,SAAS,CAACC,OAAO,KAAKjB,KAAK,CAACkB,uBAAuB;EAAA,EAAC,CAC3E,CAACC,SAAS,CAAC,UAAAH,SAAS,EAAI;IACrBhB,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAACiB,oBAAoB,GAAGrB,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAACiB,oBAAoB,GAAG,CAAC;IAC7EX,SAAS,CAACY,IAAI,CAAC;MACXC,IAAI,EAAEP,SAAS;MACfQ,IAAI,EAAEhB,KAAK;IACf,CAAC,CAAC;IACF,IAAIR,KAAK,CAACE,KAAK,CAACuB,iBAAiB,EAAE;MAC/B,OAAOzB,KAAK,CAACE,KAAK,CAACuB,iBAAiB,EAAE,CACjCpB,IAAI,CAAC;QAAA,OAAME,YAAY,EAAE;MAAA,EAAC;IACnC,CAAC,MAAM;MACH,OAAOA,YAAY,EAAE;IACzB;EACJ,CAAC,CAAC;EACN,IAAAmB,oBAAc,EACV1B,KAAK,CAAC2B,MAAM,CAACC,QAAQ,CAACd,IAAI,CACtB,IAAAC,YAAM,EAAC,UAAAa,QAAQ;IAAA,OAAI,CAAC,CAACA,QAAQ;EAAA,EAAC,CACjC,CACJ,CAACvB,IAAI,CAAC;IAAA,OAAMM,GAAG,CAACkB,WAAW,EAAE;EAAA,EAAC;EAAC,SAGjBvB,mBAAmB;IAAA;EAAA;EA6ClC;AACJ;AACA;EAFI;IAAA,qGA7CA;MAAA;MAAA;QAAA;UAAA;YACIN,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAACE,mBAAmB,GAAGN,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAACE,mBAAmB,GAAG,CAAC;YAAC,KACxEN,KAAK,CAAC2B,MAAM,CAACC,QAAQ,CAACE,QAAQ,EAAE;cAAA;cAAA;YAAA;YAAA;UAAA;YAIpC9B,KAAK,CAAC+B,eAAe,GAAG/B,KAAK,CAAC+B,eAAe,CAAC1B,IAAI,CAAC;cAAA,OAAM,IAAA2B,gCAAoB,EAAChC,KAAK,EAAE,IAAI,CAAC;YAAA,EAAC;YAAC;YAAA,OACjDA,KAAK,CAAC+B,eAAe;UAAA;YAA5DE,cAA8B;YAE5BC,QAAwB,GAAG,EAAE;UAAA;YAAA,IAC3BlC,KAAK,CAAC2B,MAAM,CAACC,QAAQ,CAACE,QAAQ,EAAE;cAAA;cAAA;YAAA;YACpCrB,oBAAoB,GAAGD,KAAK,EAAE;YAAC;YAAA,OACRR,KAAK,CAACE,KAAK,CAACU,YAAY,CAACuB,wBAAwB,CACpEnC,KAAK,CAACE,KAAK,CAACkC,aAAa,EACzBH,cAAc,CACjB;UAAA;YAHKI,QAAQ;YAAA,MAIVA,QAAQ,CAACC,SAAS,CAACC,MAAM,KAAK,CAAC;cAAA;cAAA;YAAA;YAAA;UAAA;YAInCN,cAAc,GAAG,IAAAO,iCAAgB,EAAC,CAACP,cAAc,EAAEI,QAAQ,CAACI,UAAU,CAAC,CAAC;YAExEP,QAAQ,CAACZ,IAAI,CACToB,eAAe,CACXL,QAAQ,CAACC,SAAS,EAClB,IAAAK,qBAAc,EAACV,cAAc,CAAC,CACjC,CACJ;YAAC;YAAA;UAAA;YAAA;YAAA,OAQyBW,OAAO,CAACC,GAAG,CAACX,QAAQ,CAAC;UAAA;YAA9CY,gBAAgB;YAChBC,YAAY,GAAGD,gBAAgB,CAACE,IAAI,CAAC,UAAAC,CAAC;cAAA,OAAI,CAAC,CAACA,CAAC;YAAA,EAAC;YAAA,KAChDF,YAAY;cAAA;cAAA;YAAA;YAAA;YAAA,OACNzC,mBAAmB,EAAE;UAAA;YAAA;YAAA;UAAA;YACxB,IAAI,CAACN,KAAK,CAACkD,aAAa,CAAC9C,EAAE,CAAC0B,QAAQ,EAAE,EAAE;cAC3C9B,KAAK,CAACkD,aAAa,CAAC9C,EAAE,CAAC+C,IAAI,CAAC,IAAI,CAAC;YACrC;UAAC;UAAA;YAAA;QAAA;MAAA;IAAA,CACJ;IAAA;EAAA;EAMD,SAAS5C,YAAY,GAAG;IACpB,IACIP,KAAK,CAAC2B,MAAM,CAACC,QAAQ,CAACE,QAAQ,EAAE,IAChCpB,SAAS,CAAC6B,MAAM,KAAK,CAAC,EACxB;MACEvC,KAAK,CAAC2B,MAAM,CAACyB,MAAM,CAAChD,EAAE,CAAC+C,IAAI,CAAC,KAAK,CAAC;MAClC;IACJ;IACAnD,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAACG,YAAY,GAAGP,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAACG,YAAY,GAAG,CAAC;IAC7DP,KAAK,CAAC2B,MAAM,CAACyB,MAAM,CAAChD,EAAE,CAAC+C,IAAI,CAAC,IAAI,CAAC;IACjCnD,KAAK,CAACG,WAAW,CAACC,EAAE,GAAGJ,KAAK,CAACG,WAAW,CAACC,EAAE,CAACC,IAAI,CAAC,YAAM;MACnD;AACZ;AACA;MACY,IAAIgD,IAAiC,GAAG,EAAE;MAC1C,IAAIZ,UAA0B,GAAG,CAAC,CAAQ;MAC1C,OAAO/B,SAAS,CAAC6B,MAAM,GAAG,CAAC,EAAE;QACzB,IAAMe,YAAY,GAAG,IAAAX,qBAAc,EAACjC,SAAS,CAAC6C,KAAK,EAAE,CAAC;QACtD;AAChB;AACA;AACA;AACA;QACgB,IAAID,YAAY,CAAC9B,IAAI,GAAGf,oBAAoB,EAAE;UAC1C;QACJ;QAEA4C,IAAI,GAAGA,IAAI,CAACG,MAAM,CACdF,YAAY,CAAC/B,IAAI,CAACI,MAAM,CAAC8B,GAAG,CAAC,UAAAR,CAAC,EAAI;UAC9B,OAAOA,CAAC,CAACS,YAAY;QACzB,CAAC,CAAC,CACL;QACDjB,UAAU,GAAG,IAAAD,iCAAgB,EAAC,CAACC,UAAU,EAAEa,YAAY,CAAC/B,IAAI,CAACkB,UAAU,CAAC,CAAC;MAC7E;MAEA,IAAMkB,OAAO,GAAGN,IAAI,CAACd,MAAM,KAAK,CAAC,GAAGqB,4BAAqB,GAAGlB,eAAe,CACvEW,IAAI,EACJZ,UAAU,CACb;MACD,OAAOkB,OAAO,CAACtD,IAAI,CAAC,YAAM;QACtB,IAAIK,SAAS,CAAC6B,MAAM,KAAK,CAAC,EAAE;UACxBvC,KAAK,CAAC2B,MAAM,CAACyB,MAAM,CAAChD,EAAE,CAAC+C,IAAI,CAAC,KAAK,CAAC;QACtC,CAAC,MAAM;UACH5C,YAAY,EAAE;QAClB;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEA,IAAIsD,gBAAkC,GAAGD,4BAAqB;EAC9D,IAAME,sBAGL,GAAG;IACAT,IAAI,EAAE,CAAC;EACX,CAAC;;EAED;AACJ;AACA;AACA;EACI,SAASX,eAAe,CACpBW,IAAiC,EACjCZ,UAA0B,EACV;IAChBzC,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAACsC,eAAe,GAAG1C,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAACsC,eAAe,GAAG,CAAC;;IAEnE;AACR;AACA;IACQW,IAAI,CAACU,OAAO,CAAC,UAAAC,OAAO,EAAI;MACpB,IAAMC,KAAa,GAAID,OAAO,CAAShE,KAAK,CAACkE,WAAW,CAAC;MACzDJ,sBAAsB,CAACT,IAAI,CAACY,KAAK,CAAC,GAAGD,OAAO;IAChD,CAAC,CAAC;IACFF,sBAAsB,CAACrB,UAAU,GAAGA,UAAU;IAG9CoB,gBAAgB,GAAGA,gBAAgB,CAACxD,IAAI,6FAAC;MAAA;MAAA;QAAA;UAAA;YAAA,KACjCL,KAAK,CAAC2B,MAAM,CAACC,QAAQ,CAACE,QAAQ,EAAE;cAAA;cAAA;YAAA;YAAA,kCACzB,KAAK;UAAA;YAGVqC,UAA2C,GAAGL,sBAAsB,CAACT,IAAI;YAC/ES,sBAAsB,CAACT,IAAI,GAAG,CAAC,CAAC;YAC1Be,aAAa,GAAGN,sBAAsB,CAACrB,UAAU;YACjD4B,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACJ,UAAU,CAAC;YAAA,MAClCE,MAAM,CAAC9B,MAAM,KAAK,CAAC;cAAA;cAAA;YAAA;YAAA,kCACZ,KAAK;UAAA;YAAA;YAAA,OAGiB,IAAAiC,mCAAqB,EAClDxE,KAAK,EACLqE,MAAM,CACT;UAAA;YAHKI,kBAAkB;YAKlBC,iBAAiE,GAAG,CAAC,CAAC;YACtEC,oBAA8B,GAAG,EAAE;YACnCC,eAA2D,GAAG,CAAC,CAAC;YAChEC,aAA8C,GAAG,CAAC,CAAC;YAAA;YAAA,OAEnDjC,OAAO,CAACC,GAAG,CACbwB,MAAM,CAACZ,GAAG;cAAA,0FAAC,iBAAOQ,KAAK;gBAAA;gBAAA;kBAAA;oBAAA;sBACba,WAAsC,GAAGX,UAAU,CAACF,KAAK,CAAC;sBAChEY,aAAa,CAACZ,KAAK,CAAC,GAAGa,WAAW;sBAC5Bd,OAA+B,GAAG,IAAAe,0BAAkB,EAACD,WAAW,CAAC;sBACjEE,gBAAgB,GAAGP,kBAAkB,CAACR,KAAK,CAAC;sBAElD;AACpB;AACA;AACA;AACA;sBAJoB,cAOQe,gBAAgB;sBAChB;sBACAA,gBAAgB,CAACC,YAAY,CAACC,kBAAkB,KAAKJ,WAAW,CAACK,IAAI;sBAAA;wBAAA;wBAAA;sBAAA;sBAAA;sBAAA,OAE9DnF,KAAK,CAACE,KAAK,CAACkF,eAAe,CAAC;wBAC/BC,eAAe,EAAEL,gBAAgB,CAAChB,OAAO;wBACzCsB,gBAAgB,EAAEtB;sBACtB,CAAC,EAAE,yBAAyB,CAAC;oBAAA;sBAAA,4BAAEuB,OAAO;oBAAA;sBAAA;sBAAA;wBAAA;wBAAA;sBAAA;sBAAA;sBAG1C;AACxB;AACA;AACA;AACA;;sBAE4BP,gBAAgB,IACfA,gBAAgB,CAAChB,OAAO,CAASmB,IAAI,IACtC,IAAAK,oBAAa,EAACV,WAAW,CAACK,IAAI,CAAC,CAACM,MAAM,KAAKX,WAAW,CAACY,KAAK,CAAC1F,KAAK,CAACE,KAAK,CAACyF,UAAU,CAAC;oBAAA;sBAAA;wBAAA;wBAAA;sBAAA;sBAAA;oBAAA;sBAM5FhB,oBAAoB,CAACrD,IAAI,CAAC2C,KAAK,CAAC;sBAEhCS,iBAAiB,CAACT,KAAK,CAAC,GAAG;wBACvBQ,kBAAkB,EAAEO,gBAAgB,GAAGA,gBAAgB,CAAChB,OAAO,GAAG4B,SAAS;wBAC3EN,gBAAgB,EAAEtB;sBACtB,CAAC;sBACDY,eAAe,CAACX,KAAK,CAAC,GAAG,IAAA4B,6BAAe,EACpC7F,KAAK,EACLgE,OAAO,EACPgB,gBAAgB,GAAGA,gBAAgB,CAACC,YAAY,GAAGW,SAAS,CAC/D;oBAAC;oBAAA;sBAAA;kBAAA;gBAAA;cAAA,CACL;cAAA;gBAAA;cAAA;YAAA,IAAC,CACL;UAAA;YAAA,MAEGjB,oBAAoB,CAACpC,MAAM,KAAK,CAAC;cAAA;cAAA;YAAA;YAAA,kCAC1B,KAAK;UAAA;YAIVuD,cAAc,GAAGxB,MAAM,CAACyB,MAAM,CAACrB,iBAAiB,CAAC;YACjDsB,WAAwB,GAAG,IAAIC,GAAG,EAAE;YACpCC,aAA2C,GAAG,CAAC,CAAC;YAEtD;AACZ;AACA;AACA;AACA;AACA;YACkBC,YAAY,GAAG,IAAAC,iBAAU,EAACN,cAAc,EAAE9F,KAAK,CAACE,KAAK,CAACkC,aAAa,CAAC;YAAA;YAAA,OACpEQ,OAAO,CAACC,GAAG,CACbsD,YAAY,CAAC1C,GAAG;cAAA,0FAAC,kBAAO4C,UAAU;gBAAA;gBAAA;kBAAA;oBAAA;sBAAA;sBAAA,OACEpG,kBAAkB,CAACqG,WAAW,CAACD,UAAU,CAAC;oBAAA;sBAApEE,iBAAiB;sBACvBA,iBAAiB,CAACxC,OAAO,CAAC,UAAAyC,WAAW,EAAI;wBACrC,IAAMC,EAAE,GAAID,WAAW,CAASxG,KAAK,CAACkE,WAAW,CAAC;wBAClD8B,WAAW,CAACU,GAAG,CAACD,EAAE,CAAC;wBACnBP,aAAa,CAACO,EAAE,CAAC,GAAGD,WAAW;sBACnC,CAAC,CAAC;oBAAC;oBAAA;sBAAA;kBAAA;gBAAA;cAAA,CACN;cAAA;gBAAA;cAAA;YAAA,IAAC,CACL;UAAA;YAGKG,kBAA4D,GAAG,EAAE;YAGvEhC,oBAAoB,CAACZ,OAAO,CAAC,UAAAE,KAAK,EAAI;cAClC,IAAI,CAAC+B,WAAW,CAACY,GAAG,CAAC3C,KAAK,CAAC,EAAE;gBACzBjE,KAAK,CAAC2B,MAAM,CAACkF,SAAS,CAACzG,EAAE,CAAC+C,IAAI,CAACuB,iBAAiB,CAACT,KAAK,CAAC,CAAC;gBACxD0C,kBAAkB,CAACrF,IAAI,CAACsD,eAAe,CAACX,KAAK,CAAC,CAAC;cACnD;YACJ,CAAC,CAAC;YAAC,MAEC0C,kBAAkB,CAACpE,MAAM,GAAG,CAAC;cAAA;cAAA;YAAA;YAAA;YAAA,OACvBvC,KAAK,CAACE,KAAK,CAAC4G,YAAY,CAACC,SAAS,CACpCJ,kBAAkB,EAClB,2BAA2B,CAC9B;UAAA;YAIL;AACZ;AACA;AACA;AACA;AACA;YACgBK,iBAAiB,GAAG,KAAK;YAAA,MACzBhB,WAAW,CAACiB,IAAI,GAAG,CAAC;cAAA;cAAA;YAAA;YACpBjH,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAAC8G,2BAA2B,GAAGlH,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAAC8G,2BAA2B,GAAG,CAAC;YACrFC,iBAA4C,GAAG,EAAE;YACjDC,iBAA6D,GAAG,CAAC,CAAC;YAAA;YAAA,OAClExE,OAAO,CAACC,GAAG,CACbyB,MAAM,CACD+C,OAAO,CAACnB,aAAa,CAAC,CACtBzC,GAAG,CAAC,iBAA8B;cAAA,IAA5BQ,KAAK;gBAAEoB,eAAe;cACzB,IAAMiC,gBAAgB,GAAG5C,iBAAiB,CAACT,KAAK,CAAC;cACjD,IAAM/D,KAAK,GAAG;gBACVoF,gBAAgB,EAAEgC,gBAAgB,CAAChC,gBAAgB;gBACnDb,kBAAkB,EAAE6C,gBAAgB,CAAC7C,kBAAkB;gBACvDY,eAAe,EAAfA;cACJ,CAAC;cACD,OAAO,IAAAkC,+BAAoB,EACvBvH,KAAK,EACLE,KAAK,EACL2E,aAAa,CAACZ,KAAK,CAAC,CACvB,CAAC5D,IAAI,CAAC,UAAAmH,QAAQ,EAAI;gBACf,IAAIA,QAAQ,EAAE;kBACVxH,KAAK,CAAC2B,MAAM,CAAC8F,iBAAiB,CAACtE,IAAI,CAAC;oBAChCjD,KAAK,EAALA,KAAK;oBACLwH,MAAM,EAAEF,QAAQ,CAACE;kBACrB,CAAC,CAAC;kBACFP,iBAAiB,CAAC7F,IAAI,CAAC;oBACnBqG,QAAQ,EAAE9C,aAAa,CAACZ,KAAK,CAAC;oBAC9B2D,QAAQ,EAAEJ,QAAQ,CAACK;kBACvB,CAAC,CAAC;kBACF,IAAM7C,gBAAgB,GAAGP,kBAAkB,CAACR,KAAK,CAAC;kBAClDmD,iBAAiB,CAACnD,KAAK,CAAC,GAAG,IAAA4B,6BAAe,EACtC7F,KAAK,EACL,IAAA2C,qBAAc,EAAC0C,eAAe,CAAC,EAC/BL,gBAAgB,GAAGA,gBAAgB,CAACC,YAAY,GAAGW,SAAS,EAC5D4B,QAAQ,CAACK,WAAW,CAAC1C,IAAI,CAC5B;gBACL;cACJ,CAAC,CAAC;YACN,CAAC,CAAC,CACT;UAAA;YAAA,MAEGgC,iBAAiB,CAAC5E,MAAM,GAAG,CAAC;cAAA;cAAA;YAAA;YAC5ByE,iBAAiB,GAAG,IAAI;YAExBhH,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAAC0H,6BAA6B,GAAG9H,KAAK,CAACoB,KAAK,CAAChB,EAAE,CAAC0H,6BAA6B,GAAG,CAAC;YAAC;YAAA,OAClE9H,KAAK,CAACE,KAAK,CAACU,YAAY,CAACmG,SAAS,CAC5DI,iBAAiB,EACjB,+BAA+B,CAClC;UAAA;YAHKY,eAAe;YAIrB;AACpB;AACA;AACA;AACA;AACA;YAC0BC,aAAuD,GAAG,EAAE;YAClE1D,MAAM,CACDC,IAAI,CAACwD,eAAe,CAACE,OAAO,CAAC,CAC7BlE,OAAO,CAAC,UAACE,KAAK,EAAK;cAChB+D,aAAa,CAAC1G,IAAI,CACd8F,iBAAiB,CAACnD,KAAK,CAAC,CAC3B;YACL,CAAC,CAAC;YAAC,MACH+D,aAAa,CAACzF,MAAM,GAAG,CAAC;cAAA;cAAA;YAAA;YAAA;YAAA,OAClBvC,KAAK,CAACE,KAAK,CAAC4G,YAAY,CAACC,SAAS,CACpCiB,aAAa,EACb,oCAAoC,CACvC;UAAA;YAMb;AACZ;AACA;AACA;AACA;YACYhI,KAAK,CAAC+B,eAAe,GAAG/B,KAAK,CAAC+B,eAAe,CAAC1B,IAAI,CAAC;cAAA,OAAM,IAAA6H,yBAAa,EAClElI,KAAK,EACL,IAAI,EACJoE,aAAa,CAChB;YAAA,EAAC;YAAC,kCAEI4C,iBAAiB;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA,CAC3B,GAAC,SAAM,CAAC,UAAAmB,cAAc,EAAI;MACvBnI,KAAK,CAAC2B,MAAM,CAACyG,KAAK,CAACjF,IAAI,CAACgF,cAAc,CAAC;MACvC,OAAO,KAAK;IAChB,CAAC,CAAC;IAEF,OAAOtE,gBAAgB;EAC3B;AACJ"}