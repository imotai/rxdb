{"version":3,"file":"index.js","names":["AES","cryptoEnc","objectPath","wrapRxStorageInstance","INTERNAL_STORE_SCHEMA_TITLE","newRxError","newRxTypeError","hasEncryption","b64DecodeUnicode","b64EncodeUnicode","clone","ensureNotFalsy","flatClone","MINIMUM_PASSWORD_LENGTH","encryptString","value","password","encrypted","encrypt","toString","decryptString","cipherText","args","decrypted","decrypt","ret","wrappedKeyEncryptionStorage","Object","assign","storage","createStorageInstance","params","modifyToStorage","modifyFromStorage","modifyAttachmentFromStorage","attachmentData","schema","attachments","docData","cloneWithoutAttachments","forEach","path","get","decryptedParsed","JSON","parse","set","stringValue","stringify","newAttachments","entries","_attachments","id","attachment","useAttachment","data","dataString","retInstance","title","validatePassword","close","database","databaseName","collection","collectionName","schemaWithoutEncrypted","instance","length","minPassLength"],"sources":["../../../../src/plugins/encryption/index.ts"],"sourcesContent":["/**\n * this plugin adds the encryption-capabilities to rxdb\n * It's using crypto-js/aes for password-encryption\n * @link https://github.com/brix/crypto-js\n */\nimport AES from 'crypto-js/aes';\nimport * as cryptoEnc from 'crypto-js/enc-utf8';\nimport objectPath from 'object-path';\nimport { wrapRxStorageInstance } from '../../plugin-helpers';\nimport {\n    INTERNAL_STORE_SCHEMA_TITLE\n} from '../../rx-database-internal-store';\nimport { newRxError, newRxTypeError } from '../../rx-error';\nimport { hasEncryption } from '../../rx-storage-helper';\nimport type {\n    InternalStoreDocType,\n    RxAttachmentWriteData,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageInstanceCreationParams\n} from '../../types';\nimport {\n    b64DecodeUnicode,\n    b64EncodeUnicode,\n    clone,\n    ensureNotFalsy,\n    flatClone\n} from '../../plugins/utils';\n\nexport const MINIMUM_PASSWORD_LENGTH: 8 = 8;\n\n\nexport function encryptString(value: string, password: string): string {\n    const encrypted = AES.encrypt(value, password);\n    return encrypted.toString();\n}\n\nexport function decryptString(cipherText: string, password: any): string {\n    /**\n     * Trying to decrypt non-strings\n     * will cause no errors and will be hard to debug.\n     * So instead we do this check here.\n     */\n    if (typeof cipherText !== 'string') {\n        throw newRxError('SNH', {\n            args: {\n                cipherText\n            }\n        });\n    }\n\n    const decrypted = AES.decrypt(cipherText, password);\n    const ret = decrypted.toString(cryptoEnc);\n    return ret;\n}\n\nexport type InternalStorePasswordDocType = InternalStoreDocType<{\n    hash: string;\n}>;\n\nexport function wrappedKeyEncryptionStorage<Internals, InstanceCreationOptions>(\n    args: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n    }\n): RxStorage<Internals, InstanceCreationOptions> {\n    return Object.assign(\n        {},\n        args.storage,\n        {\n            async createStorageInstance<RxDocType>(\n                params: RxStorageInstanceCreationParams<RxDocType, any>\n            ) {\n                if (!hasEncryption(params.schema)) {\n                    const retInstance = await args.storage.createStorageInstance(params);\n                    if (\n                        params.schema.title === INTERNAL_STORE_SCHEMA_TITLE &&\n                        params.password\n                    ) {\n                        try {\n                            validatePassword(params.password);\n                        } catch (err) {\n                            /**\n                             * Even if the checks fail,\n                             * we have to clean up.\n                             */\n                            await retInstance.close();\n                            throw err;\n                        }\n                    }\n                    return retInstance;\n                }\n\n                if (!params.password) {\n                    throw newRxError('EN3', {\n                        database: params.databaseName,\n                        collection: params.collectionName,\n                        schema: params.schema\n                    });\n                }\n                const password = params.password;\n\n                const schemaWithoutEncrypted: RxJsonSchema<RxDocumentData<RxDocType>> = clone(params.schema);\n                delete schemaWithoutEncrypted.encrypted;\n                if (schemaWithoutEncrypted.attachments) {\n                    schemaWithoutEncrypted.attachments.encrypted = false;\n                }\n\n                const instance = await args.storage.createStorageInstance(\n                    Object.assign(\n                        {},\n                        params,\n                        {\n                            schema: schemaWithoutEncrypted\n                        }\n                    )\n                );\n\n                function modifyToStorage(docData: RxDocumentWriteData<RxDocType>) {\n                    docData = cloneWithoutAttachments(docData);\n                    ensureNotFalsy(params.schema.encrypted)\n                        .forEach(path => {\n                            const value = objectPath.get(docData, path);\n                            if (typeof value === 'undefined') {\n                                return;\n                            }\n\n                            const stringValue = JSON.stringify(value);\n                            const encrypted = encryptString(stringValue, password);\n                            objectPath.set(docData, path, encrypted);\n                        });\n\n                    // handle attachments\n                    if (\n                        params.schema.attachments &&\n                        params.schema.attachments.encrypted\n                    ) {\n                        const newAttachments: typeof docData._attachments = {};\n                        Object.entries(docData._attachments).forEach(([id, attachment]) => {\n                            const useAttachment: RxAttachmentWriteData = flatClone(attachment) as any;\n                            if (useAttachment.data) {\n                                const dataString = useAttachment.data;\n                                useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));\n                            }\n                            newAttachments[id] = useAttachment;\n                        });\n                        docData._attachments = newAttachments;\n                    }\n                    return docData;\n                }\n                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {\n                    docData = cloneWithoutAttachments(docData);\n                    ensureNotFalsy(params.schema.encrypted)\n                        .forEach(path => {\n                            const value = objectPath.get(docData, path);\n                            if (typeof value === 'undefined') {\n                                return;\n                            }\n                            const decrypted = decryptString(value, password);\n                            const decryptedParsed = JSON.parse(decrypted);\n                            objectPath.set(docData, path, decryptedParsed);\n                        });\n                    return docData;\n                }\n\n                function modifyAttachmentFromStorage(attachmentData: string): string {\n                    if (\n                        params.schema.attachments &&\n                        params.schema.attachments.encrypted\n                    ) {\n                        const decrypted = decryptString(b64DecodeUnicode(attachmentData), password);\n                        return decrypted;\n                    } else {\n                        return attachmentData;\n                    }\n                }\n\n                return wrapRxStorageInstance(\n                    instance,\n                    modifyToStorage,\n                    modifyFromStorage,\n                    modifyAttachmentFromStorage\n                );\n            }\n        }\n    );\n}\n\n\n\n\n\nfunction cloneWithoutAttachments<T>(data: RxDocumentWriteData<T>): RxDocumentData<T> {\n    const attachments = data._attachments;\n    data = flatClone(data);\n    delete (data as any)._attachments;\n    data = clone(data);\n    data._attachments = attachments;\n    return data as any;\n}\n\nfunction validatePassword(password: any) {\n    if (password && typeof password !== 'string') {\n        throw newRxTypeError('EN1', {\n            password\n        });\n    }\n    if (password && password.length < MINIMUM_PASSWORD_LENGTH) {\n        throw newRxError('EN2', {\n            minPassLength: MINIMUM_PASSWORD_LENGTH,\n            password\n        });\n    }\n}\n"],"mappings":"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"}