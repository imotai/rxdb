{"version":3,"file":"non-worker.js","names":["Subject","spawn","Worker","Thread","ensureNotFalsy","getFromMapOrThrow","WORKER_BY_INSTANCE","Map","RxStorageWorker","settings","statics","name","createStorageInstance","params","workerState","get","workerPromise","workerInput","refs","Set","set","then","worker","instanceId","instance","RxStorageInstanceWorker","databaseName","collectionName","schema","rxStorage","options","add","storage","internals","changes$","conflicts$","subs","closed","push","changeStream","subscribe","ev","next","conflictResultionTasks","bulkWrite","documentWrites","context","findDocumentsById","ids","deleted","query","preparedQuery","count","getAttachmentData","documentId","attachmentId","getChangedDocumentsSince","limit","checkpoint","asObservable","cleanup","minDeletedTime","close","Promise","reject","Error","forEach","sub","unsubscribe","removeWorkerRef","remove","resolveConflictResultionTask","taskSolution","getRxStorageWorker","size","terminate"],"sources":["../../../../src/plugins/storage-worker/non-worker.ts"],"sourcesContent":["import {\n    Observable,\n    Subject,\n    Subscription\n} from 'rxjs';\nimport {\n    spawn,\n    Worker,\n    Thread\n} from 'threads';\nimport type {\n    RxJsonSchema,\n    RxStorage,\n    RxStorageInstanceCreationParams,\n    RxStorageInstance,\n    BulkWriteRow,\n    RxDocumentData,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageQueryResult,\n    EventBulk,\n    RxStorageStatics,\n    RxDocumentDataById,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxStorageCountResult\n} from '../../types';\nimport {\n    ensureNotFalsy,\n    getFromMapOrThrow\n} from '../../plugins/utils';\nimport { InWorkerStorage } from './in-worker';\n\ndeclare type WorkerStorageInternals = {\n    rxStorage: RxStorageWorker;\n    instanceId: number;\n    worker: InWorkerStorage<any, any>;\n};\ndeclare type RxStorageWorkerSettings = {\n    statics: RxStorageStatics;\n    workerInput: any;\n};\n\n\n/**\n * We have no way to detect if a worker is no longer needed.\n * So we create the worker process on the first RxStorageInstance\n * and have to close it again of no more RxStorageInstances are non-closed.\n */\nconst WORKER_BY_INSTANCE: Map<RxStorageWorker, {\n    workerPromise: Promise<InWorkerStorage<any, any>>;\n    refs: Set<RxStorageInstanceWorker<any>>;\n}> = new Map();\n\nexport class RxStorageWorker implements RxStorage<WorkerStorageInternals, any> {\n    public name = 'worker';\n\n    constructor(\n        public readonly settings: RxStorageWorkerSettings,\n        public readonly statics: RxStorageStatics\n    ) { }\n\n    createStorageInstance<RxDocType>(\n        params: RxStorageInstanceCreationParams<RxDocType, any>\n    ): Promise<RxStorageInstanceWorker<RxDocType>> {\n        let workerState = WORKER_BY_INSTANCE.get(this);\n        if (!workerState) {\n            workerState = {\n                workerPromise: spawn<InWorkerStorage<RxDocType, any>>(new Worker(this.settings.workerInput)) as any,\n                refs: new Set()\n            };\n            WORKER_BY_INSTANCE.set(this, workerState);\n        }\n\n        return workerState.workerPromise.then(worker => {\n            return worker.createStorageInstance(params)\n                .then(instanceId => {\n                    const instance = new RxStorageInstanceWorker(\n                        this,\n                        params.databaseName,\n                        params.collectionName,\n                        params.schema,\n                        {\n                            rxStorage: this,\n                            instanceId,\n                            worker\n                        },\n                        params.options\n                    );\n                    ensureNotFalsy(workerState).refs.add(instance);\n                    return instance;\n                });\n        });\n    }\n}\n\n\nexport class RxStorageInstanceWorker<RxDocType> implements RxStorageInstance<RxDocType, WorkerStorageInternals, any, any> {\n    /**\n     * threads.js uses observable-fns instead of rxjs\n     * so we have to transform it.\n     */\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, any>> = new Subject();\n    private conflicts$: Subject<RxConflictResultionTask<RxDocType>> = new Subject();\n    private subs: Subscription[] = [];\n\n    private closed: boolean = false;\n\n    constructor(\n        public readonly storage: RxStorageWorker,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: WorkerStorageInternals,\n        public readonly options: Readonly<any>\n    ) {\n        this.subs.push(\n            this.internals.worker.changeStream(\n                this.internals.instanceId\n            ).subscribe(ev => this.changes$.next(ev as any))\n        );\n        this.subs.push(\n            this.internals.worker.conflictResultionTasks(\n                this.internals.instanceId\n            ).subscribe(ev => this.conflicts$.next(ev as any))\n        );\n    }\n\n    bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        return this.internals.worker.bulkWrite(\n            this.internals.instanceId,\n            documentWrites,\n            context\n        );\n    }\n    findDocumentsById(ids: string[], deleted: boolean): Promise<RxDocumentDataById<RxDocType>> {\n        return this.internals.worker.findDocumentsById(\n            this.internals.instanceId,\n            ids,\n            deleted\n        );\n    }\n    query(preparedQuery: any): Promise<RxStorageQueryResult<RxDocType>> {\n        return this.internals.worker.query(\n            this.internals.instanceId,\n            preparedQuery\n        );\n    }\n    count(preparedQuery: any): Promise<RxStorageCountResult> {\n        return this.internals.worker.count(\n            this.internals.instanceId,\n            preparedQuery\n        );\n    }\n    getAttachmentData(documentId: string, attachmentId: string): Promise<string> {\n        return this.internals.worker.getAttachmentData(\n            this.internals.instanceId,\n            documentId,\n            attachmentId\n        );\n    }\n    getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: any\n    ) {\n        return this.internals.worker.getChangedDocumentsSince(\n            this.internals.instanceId,\n            limit,\n            checkpoint\n        );\n    }\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, any>> {\n        return this.changes$.asObservable();\n    }\n    cleanup(minDeletedTime: number) {\n        return this.internals.worker.cleanup(\n            this.internals.instanceId,\n            minDeletedTime\n        );\n    }\n    async close(): Promise<void> {\n        if (this.closed) {\n            return Promise.reject(new Error('already closed'));\n        }\n        this.closed = true;\n        this.subs.forEach(sub => sub.unsubscribe());\n        await this.internals.worker.close(\n            this.internals.instanceId\n        );\n        await removeWorkerRef(this);\n    }\n    async remove(): Promise<void> {\n        await this.internals.worker.remove(\n            this.internals.instanceId\n        );\n        this.closed = true;\n        await removeWorkerRef(this);\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return this.conflicts$;\n    }\n    async resolveConflictResultionTask(taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> {\n        await this.internals.worker.resolveConflictResultionTask(\n            this.internals.instanceId,\n            taskSolution\n        );\n    }\n\n}\n\nexport function getRxStorageWorker(\n    settings: RxStorageWorkerSettings\n): RxStorageWorker {\n    const storage = new RxStorageWorker(settings, settings.statics);\n    return storage;\n}\n\n/**\n * TODO we have a bug.\n * When the exact same RxStorage opens and closes\n * many RxStorage instances, then it might happen\n * that some calls to createStorageInstance() time out,\n * because the worker thread is in the closing state.\n */\nexport async function removeWorkerRef(\n    instance: RxStorageInstanceWorker<any>\n) {\n    const workerState = getFromMapOrThrow(WORKER_BY_INSTANCE, instance.storage);\n    workerState.refs.delete(instance);\n    if (workerState.refs.size === 0) {\n        WORKER_BY_INSTANCE.delete(instance.storage);\n        await workerState.workerPromise\n            .then(worker => Thread.terminate(worker as any));\n    }\n}\n"],"mappings":"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"}